
import os
import psycopg2
import psycopg2.extras
import tabulate
import time
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

class H:

    def __init__(mysillyobject, cust, prod, count_1_quant, count_2_quant):
        
        
        mysillyobject.cust = cust
        
        
        mysillyobject.prod = prod
        
        

        mysillyobject.count_1_quant = count_1_quant
        

        mysillyobject.count_2_quant = count_2_quant
        
    
    
def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect(host = 'localhost', dbname = dbname, user = user, password = password, port = 5432)
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    start_time = time.time()
    cur.execute(f"SELECT cust, prod, year, state, quant FROM sales")  
    
    
    instances = {}
    
    agg_instance0 = []
        
    agg_instance1 = []
        
    for row in cur:
        # Create a unique key
        attributesFormattedForKey = ""
        hInstan = {}
        for x in ['cust', 'prod']:
            attributesFormattedForKey += f"{x}-{row[x]}@"
            hInstan[x] = row[x]
        attributesFormattedForKey = attributesFormattedForKey[:-1]
        #adds placeholder values in H class for aggregate functions
        for y in ['count_1_quant', 'count_2_quant']:
            hInstan[y] = None
        key = attributesFormattedForKey
        if key not in instances:
            instances[key] = H(**hInstan)
        
        
        isUsed = True
        if not(eval("row['state']=='NJ' and row['year'] == 2018")):
            isUsed = False  
        if isUsed:
            agg_instance0.append(row)  
        
        isUsed = True
        if not(eval("row['state']=='NY' and row['year'] == 2019")):
            isUsed = False  
        if isUsed:
            agg_instance1.append(row)  
        
    
    cur.scroll(0, mode='absolute')
    h_table_grouping_attr_time = time.time()
    h_table_grouping_attr_time_total = h_table_grouping_attr_time - start_time
    print(f"H Table Grouping Atrr executed in {h_table_grouping_attr_time_total:.2f} seconds.")
    
    
    eval_string = "row['cust'] == h_row.cust and row['prod'] == h_row.prod and row['state']=='NJ' and row['year'] == 2018"
    h_table_aggrefunc_time_start = time.time()
    max_size = 10000    #Preallocating the space for the list
    for key, h_row in instances.items():
        split_key = key.split('@')
        split_key = [pair.split('-') for pair in split_key]
        agg_instance_temp = [None] * max_size
        curr_size = 0

        such_that_time_start = time.time()
        for row in agg_instance0:
            if eval(eval_string):
                agg_instance_temp[curr_size] = row
                curr_size += 1  
        such_that_time_end = time.time()
        such_that_time_total =  such_that_time_end -  such_that_time_start
        print(f" Such That Mini Table 0 Time executed in {such_that_time_total:.2f} seconds.")
        for x in ['count_1_quant', 'count_2_quant']: # for calculating the aggregate functions for the H-class table
            split_x = x.split("_")
            if split_x[0] == "sum" and split_x[1] == str(1):
                sum = 0
                for l in range(curr_size): 
                    sum += agg_instance_temp[l][split_x[2]]
                setattr(instances[key], x, sum)
                
            elif split_x[0] == "count" and split_x[1] == str(1) :
                setattr(instances[key], x, curr_size)

            elif split_x[0] == "min" and split_x[1] == str(1) :
                first = True
                for l in range(curr_size):
                    if first:
                        min = agg_instance_temp[l][split_x[2]]
                        first = False
                    else:
                        if agg_instance_temp[l][split_x[2]] < min:
                            min = agg_instance_temp[l][split_x[2]]
                setattr(instances[key], x, min)

            elif split_x[0] == "max" and split_x[1] == str(1) :
                first = True
                for l in range(curr_size):
                    if first:
                        max = agg_instance_temp[l][split_x[2]]
                        first = False
                    else:
                        if (agg_instance_temp[l][split_x[2]] > max):
                            max = agg_instance_temp[l][split_x[2]]
                setattr(instances[key], x, max)
            
            if split_x[0] == "avg" and split_x[1] == str(1) :
                sum = 0
                for l in range(curr_size): 
                    sum += agg_instance_temp[l][split_x[2]]
                avg = sum/curr_size
                setattr(instances[key], x, avg)
                            
        cur.scroll(0, mode='absolute')
    h_table_aggrefunc_time_end = time.time()
    h_table_aggrefunc_time_total = h_table_aggrefunc_time_end - h_table_aggrefunc_time_start
    print(f" H Table AggreFunc 0 Time executed in {h_table_aggrefunc_time_total:.2f} seconds.")
    
    eval_string = "row['cust'] == h_row.cust and row['prod'] == h_row.prod and row['state']=='NY' and row['year'] == 2019"
    h_table_aggrefunc_time_start = time.time()
    max_size = 10000    #Preallocating the space for the list
    for key, h_row in instances.items():
        split_key = key.split('@')
        split_key = [pair.split('-') for pair in split_key]
        agg_instance_temp = [None] * max_size
        curr_size = 0

        such_that_time_start = time.time()
        for row in agg_instance1:
            if eval(eval_string):
                agg_instance_temp[curr_size] = row
                curr_size += 1  
        such_that_time_end = time.time()
        such_that_time_total =  such_that_time_end -  such_that_time_start
        print(f" Such That Mini Table 1 Time executed in {such_that_time_total:.2f} seconds.")
        for x in ['count_1_quant', 'count_2_quant']: # for calculating the aggregate functions for the H-class table
            split_x = x.split("_")
            if split_x[0] == "sum" and split_x[1] == str(2):
                sum = 0
                for l in range(curr_size): 
                    sum += agg_instance_temp[l][split_x[2]]
                setattr(instances[key], x, sum)
                
            elif split_x[0] == "count" and split_x[1] == str(2) :
                setattr(instances[key], x, curr_size)

            elif split_x[0] == "min" and split_x[1] == str(2) :
                first = True
                for l in range(curr_size):
                    if first:
                        min = agg_instance_temp[l][split_x[2]]
                        first = False
                    else:
                        if agg_instance_temp[l][split_x[2]] < min:
                            min = agg_instance_temp[l][split_x[2]]
                setattr(instances[key], x, min)

            elif split_x[0] == "max" and split_x[1] == str(2) :
                first = True
                for l in range(curr_size):
                    if first:
                        max = agg_instance_temp[l][split_x[2]]
                        first = False
                    else:
                        if (agg_instance_temp[l][split_x[2]] > max):
                            max = agg_instance_temp[l][split_x[2]]
                setattr(instances[key], x, max)
            
            if split_x[0] == "avg" and split_x[1] == str(2) :
                sum = 0
                for l in range(curr_size): 
                    sum += agg_instance_temp[l][split_x[2]]
                avg = sum/curr_size
                setattr(instances[key], x, avg)
                            
        cur.scroll(0, mode='absolute')
    h_table_aggrefunc_time_end = time.time()
    h_table_aggrefunc_time_total = h_table_aggrefunc_time_end - h_table_aggrefunc_time_start
    print(f" H Table AggreFunc 1 Time executed in {h_table_aggrefunc_time_total:.2f} seconds.")
    
    
     
    keys_to_remove = []
    if True:
        having_time_start = time.time()
        having_string = "h_row.count_1_quant < h_row.count_2_quant /2"
        for key, h_row in instances.items():
            if not(eval(having_string)):
                keys_to_remove.append(key)
        for key in keys_to_remove:
            del instances[key]
        having_time_end = time.time()
        having_time_total = having_time_end - having_time_start
        print(f" Having Time executed in {having_time_total:.2f} seconds.")
    
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Query executed in {elapsed_time:.2f} seconds.")
    table_data = [vars(inst) for inst in instances.values()]
    return tabulate.tabulate(table_data, headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    